{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Groundwork An integrated Django and Javascript framework for rapidly building tools.","title":"Home"},{"location":"#groundwork","text":"An integrated Django and Javascript framework for rapidly building tools.","title":"Groundwork"},{"location":"code-style/","text":"Style guide All public APIs must be fully documented. We use Google docstring format . These will at some point be extracted into searchable API docs, so it's important to get this right. A linter will check for you that they are correctly formatted. Aim for 100% test coverage on public APIs. Use type hints. Format your code. Run make formatting to do this explicitly. If you run make bootstrap to setup the project (as the devcontainer does automatically), you should get pre-commit hooks installed that do this for you. Check that all checks pass before requesting a PR review. You can do this using make lint Individual checks are documented at: https://pypi.org/project/darglint/ https://pypi.org/project/isort/ https://mypy-lang.org/ https://pypi.org/project/safety/ https://pypi.org/project/bandit/ Rules are configured in pyproject.yaml","title":"Code Style"},{"location":"code-style/#style-guide","text":"All public APIs must be fully documented. We use Google docstring format . These will at some point be extracted into searchable API docs, so it's important to get this right. A linter will check for you that they are correctly formatted. Aim for 100% test coverage on public APIs. Use type hints. Format your code. Run make formatting to do this explicitly. If you run make bootstrap to setup the project (as the devcontainer does automatically), you should get pre-commit hooks installed that do this for you. Check that all checks pass before requesting a PR review. You can do this using make lint Individual checks are documented at: https://pypi.org/project/darglint/ https://pypi.org/project/isort/ https://mypy-lang.org/ https://pypi.org/project/safety/ https://pypi.org/project/bandit/ Rules are configured in pyproject.yaml","title":"Style guide"},{"location":"contributing/","text":"Contributor workflow Creating a high-level pattern library like this one comes with risks. The most significant one is premature abstraction. Our general approach here is that API design happens best in the context of real-world applications. Features should be proposed for this library once they have reached a certain level of stability. We don't want to have an excessively prescriptive sense of what is 'in' and 'out' of scope for this library. So long as something fits within our architecture, is testable and has an API that has stabilised through real-world use, it's a candidate for inclusion. New features and functionality The first stage of adding a new module happens within an application that uses it. Use the convention of placing it in the groundwork.experimental package within your application repository to indicate to other people that it's in the process of being abstracted and that they should be mindful of these guidelines. Remove any dependencies from application code outside the groundwork package. Start to think about how it can be tested in isolation (if it isn't already). Open a feature request against this repository. Describe the new feature, include links to your implementation other repositories. If the application is publicly accessible, include links to it in the live app. Discuss and refine the API with other contributors. When the feature request is accepted, fork this repository (or create a feature branch if you have write access) and commit the feature implementation. Ensure that you have good test coverage of both Python and Javascript components and all public API methods are documented. Bugs & backward-compatible API changes We're more open to backward-compatible API changes. For smaller changes, opening a pull request is fine. Some additional pointers: Ensure that you have good test coverage of both Python and Javascript components and all public API methods are documented. These changes are always a good opportuntiy to improve test coverage of the exsting functionality. Think about how your changes may lead to regressions to the existing functionality and add tests to guard against them. Improvements to documentation Yes please! Releases Releases are published to package managers when a release tag in vX.X.X format is published in GitHub. We follow the Semantic Versioning spec for release numbers.","title":"Contribution Guidelines"},{"location":"contributing/#contributor-workflow","text":"Creating a high-level pattern library like this one comes with risks. The most significant one is premature abstraction. Our general approach here is that API design happens best in the context of real-world applications. Features should be proposed for this library once they have reached a certain level of stability. We don't want to have an excessively prescriptive sense of what is 'in' and 'out' of scope for this library. So long as something fits within our architecture, is testable and has an API that has stabilised through real-world use, it's a candidate for inclusion.","title":"Contributor workflow"},{"location":"contributing/#new-features-and-functionality","text":"The first stage of adding a new module happens within an application that uses it. Use the convention of placing it in the groundwork.experimental package within your application repository to indicate to other people that it's in the process of being abstracted and that they should be mindful of these guidelines. Remove any dependencies from application code outside the groundwork package. Start to think about how it can be tested in isolation (if it isn't already). Open a feature request against this repository. Describe the new feature, include links to your implementation other repositories. If the application is publicly accessible, include links to it in the live app. Discuss and refine the API with other contributors. When the feature request is accepted, fork this repository (or create a feature branch if you have write access) and commit the feature implementation. Ensure that you have good test coverage of both Python and Javascript components and all public API methods are documented.","title":"New features and functionality"},{"location":"contributing/#bugs-backward-compatible-api-changes","text":"We're more open to backward-compatible API changes. For smaller changes, opening a pull request is fine. Some additional pointers: Ensure that you have good test coverage of both Python and Javascript components and all public API methods are documented. These changes are always a good opportuntiy to improve test coverage of the exsting functionality. Think about how your changes may lead to regressions to the existing functionality and add tests to guard against them.","title":"Bugs &amp; backward-compatible API changes"},{"location":"contributing/#improvements-to-documentation","text":"Yes please!","title":"Improvements to documentation"},{"location":"contributing/#releases","text":"Releases are published to package managers when a release tag in vX.X.X format is published in GitHub. We follow the Semantic Versioning spec for release numbers.","title":"Releases"},{"location":"developing/","text":"Easy mode: Development containers We love development containers. They keep your development environment in a VM and isolated from the rest of your device which is good security practice. They also make it extremely easy to share editor configurations and development dependencies that can't be managed using language package managers. Much as we hate to stan Microsoft , it's the easiest option to work on this library. (you may be interested in trying out VSCodium , an opensource distribution of VSCode) In Visual Studio Code From the command palette select \"Remote Containers: Clone Repository in Named Container Volume\". Enter: git@github.com:commonknowledge/groundwork.git . Choose a development container to install to, or create a new one. Wait for the container to initialize and the project bootstrap scripts to finish. More information VSCode Development Containers Hard mode: Do it yourself Ensure that you have the following installed: NodeJS Yarn Python 3.9+ Poetry Follow the installation instructions for DjangoGIS's local dependencies . Ensure that you have the DATABASE_URL environmental variable pointing to a local postgres database. Clone the repository and run make bootstrap .","title":"Developer Setup"},{"location":"developing/#easy-mode-development-containers","text":"We love development containers. They keep your development environment in a VM and isolated from the rest of your device which is good security practice. They also make it extremely easy to share editor configurations and development dependencies that can't be managed using language package managers. Much as we hate to stan Microsoft , it's the easiest option to work on this library. (you may be interested in trying out VSCodium , an opensource distribution of VSCode)","title":"Easy mode: Development containers"},{"location":"developing/#in-visual-studio-code","text":"From the command palette select \"Remote Containers: Clone Repository in Named Container Volume\". Enter: git@github.com:commonknowledge/groundwork.git . Choose a development container to install to, or create a new one. Wait for the container to initialize and the project bootstrap scripts to finish.","title":"In Visual Studio Code"},{"location":"developing/#more-information","text":"VSCode Development Containers","title":"More information"},{"location":"developing/#hard-mode-do-it-yourself","text":"Ensure that you have the following installed: NodeJS Yarn Python 3.9+ Poetry Follow the installation instructions for DjangoGIS's local dependencies . Ensure that you have the DATABASE_URL environmental variable pointing to a local postgres database. Clone the repository and run make bootstrap .","title":"Hard mode: Do it yourself"},{"location":"api/groundwork.contrib.airtable.datasources/","text":"import groundwork.contrib.airtable.datasources airtable_field airtable_field( name: str, **kwargs: Dict[str, Any]) \u2011> dataclasses.Field Return a dataclass field used to annotate a Resource class with the name of the column in Airtable. For example, if you have an Airtable like this: First Name Last Name Stafford Beer Clara Zetkin You could map it onto a django model like this: @dataclass class People : id : str first_name : str = airtable_field ( 'First Name' ) last_name : str = airtable_field ( 'Last Name' ) If you do not annotate your field like this, AirtableDatasource will expect your column in Airtable to have the same name as your Resource class. Parameters name Airtable column name associated with this field. kwargs Keyword args passed to dataclasses.field . Returns A dataclass field descriptor identifying the corresponding Airtable column. AirtableDatasource Base class for implementing clients to Airtable bases and converting their responses to resource objects. You are encouraged to use Python's inbuilt @dataclass decorator and define type hints when defining these classes as this allows type-safe serializers to be auto-generated and decreases the amount of boilerplate code that you need to write. Example: Let's assume we have a public airtable with the base id 4rQYK6P56My . It contains a table called 'Active Members', which looks like this: First Name Last Name Stafford Beer Clara Zetkin We can create a datasource for it as follows: from dataclasses import dataclass from groundwork.contrib.airtable.datasources import AirtableDatasource , airtable_field @dataclass class Person : id : str first_name : str = airtable_field ( 'First Name' ) last_name : str = airtable_field ( 'Last Name' ) my_datasource = AirtableDatasource ( base_id = \"4rQYK6P56My\" , table_name = \"Active Members\" , resource_class = Person , ) As with other datasource types, configuration can all either be provided as keyword-args to the constructor, or overridden in subclasses. Inherits: groundwork.core.datasources.RestDatasource groundwork.core.datasources.Datasource Constructor : AirtableDatasource(resource_type: ~ResourceT, base=None, table=None, **kwargs) Class variables api_key str Airtable API key. Required for private Airtable bases. If not defined, will default to the value of django.conf.settings.AIRTABLE_API_KEY . base_id Optional[str] ID of the airtable base. You can find this in your base's API Docs table_name Optional[str] Name of the table to fetch from.","title":"Data Sources"},{"location":"api/groundwork.contrib.airtable.datasources/#airtable_field","text":"airtable_field( name: str, **kwargs: Dict[str, Any]) \u2011> dataclasses.Field Return a dataclass field used to annotate a Resource class with the name of the column in Airtable. For example, if you have an Airtable like this: First Name Last Name Stafford Beer Clara Zetkin You could map it onto a django model like this: @dataclass class People : id : str first_name : str = airtable_field ( 'First Name' ) last_name : str = airtable_field ( 'Last Name' ) If you do not annotate your field like this, AirtableDatasource will expect your column in Airtable to have the same name as your Resource class. Parameters name Airtable column name associated with this field. kwargs Keyword args passed to dataclasses.field . Returns A dataclass field descriptor identifying the corresponding Airtable column.","title":"airtable_field"},{"location":"api/groundwork.contrib.airtable.datasources/#airtabledatasource","text":"Base class for implementing clients to Airtable bases and converting their responses to resource objects. You are encouraged to use Python's inbuilt @dataclass decorator and define type hints when defining these classes as this allows type-safe serializers to be auto-generated and decreases the amount of boilerplate code that you need to write. Example: Let's assume we have a public airtable with the base id 4rQYK6P56My . It contains a table called 'Active Members', which looks like this: First Name Last Name Stafford Beer Clara Zetkin We can create a datasource for it as follows: from dataclasses import dataclass from groundwork.contrib.airtable.datasources import AirtableDatasource , airtable_field @dataclass class Person : id : str first_name : str = airtable_field ( 'First Name' ) last_name : str = airtable_field ( 'Last Name' ) my_datasource = AirtableDatasource ( base_id = \"4rQYK6P56My\" , table_name = \"Active Members\" , resource_class = Person , ) As with other datasource types, configuration can all either be provided as keyword-args to the constructor, or overridden in subclasses. Inherits: groundwork.core.datasources.RestDatasource groundwork.core.datasources.Datasource Constructor : AirtableDatasource(resource_type: ~ResourceT, base=None, table=None, **kwargs)","title":"AirtableDatasource"},{"location":"api/groundwork.contrib.airtable.datasources/#class-variables","text":"","title":"Class variables"},{"location":"api/groundwork.contrib.airtable.datasources/#api_key","text":"str Airtable API key. Required for private Airtable bases. If not defined, will default to the value of django.conf.settings.AIRTABLE_API_KEY .","title":"api_key"},{"location":"api/groundwork.contrib.airtable.datasources/#base_id","text":"Optional[str] ID of the airtable base. You can find this in your base's API Docs","title":"base_id"},{"location":"api/groundwork.contrib.airtable.datasources/#table_name","text":"Optional[str] Name of the table to fetch from.","title":"table_name"},{"location":"api/groundwork.contrib.airtable/","text":"import groundwork.contrib.airtable groundwork.contrib.airtable.datasources","title":"Groundwork.contrib.airtable"},{"location":"api/groundwork.core.cache/","text":"import groundwork.core.cache django_cached django_cached( prefix: str, get_key: Any = None, ttl: int = 500) \u2011> Callable[[~_T], ~_T] Decorator to cache a function using the default cache. Parameters get_key Return a cache key given the arguments to the function prefix Prefix applied to the cache key ttl TTL in seconds Returns A function decorator django_cached_model_property django_cached_model_property( prefix: str, get_key: Any = None, ttl: int = 500) \u2011> Callable[[~_T], ~_T] Decorator to cache a model method using the default cache, scoped to the model instance. Parameters get_key Return a cache key given the arguments to the function prefix Prefix applied to the cache key ttl TTL in seconds Returns A method decorator","title":"Cache utils"},{"location":"api/groundwork.core.cache/#django_cached","text":"django_cached( prefix: str, get_key: Any = None, ttl: int = 500) \u2011> Callable[[~_T], ~_T] Decorator to cache a function using the default cache. Parameters get_key Return a cache key given the arguments to the function prefix Prefix applied to the cache key ttl TTL in seconds Returns A function decorator","title":"django_cached"},{"location":"api/groundwork.core.cache/#django_cached_model_property","text":"django_cached_model_property( prefix: str, get_key: Any = None, ttl: int = 500) \u2011> Callable[[~_T], ~_T] Decorator to cache a model method using the default cache, scoped to the model instance. Parameters get_key Return a cache key given the arguments to the function prefix Prefix applied to the cache key ttl TTL in seconds Returns A method decorator","title":"django_cached_model_property"},{"location":"api/groundwork.core.cron/","text":"import groundwork.core.cron register_cron register_cron( fn: Callable[[], None], interval: datetime.timedelta) \u2011> None Registers a cron task to run at a specified interval. Calling this function alone will not do anything. In order to run pending cron tasks, you must call run_pending_cron_tasks (the included management task run_pending_cron_tasks will do this for you on a loop) Parameters fn Function implementing the cron task. interval Interval to run the cron task at. run_pending_cron_tasks run_pending_cron_tasks( all: bool = False) \u2011> None Runs all pending cron tasks then returns. You usually won't want to call this \u2013 unless yu are implementing a custom clock process. In general, you'll want the management command run_pending_cron_tasks , which calls this for you on a loop. Parameters all Run all tasks regardless of whether they're scheduled","title":"Cron tasks"},{"location":"api/groundwork.core.cron/#register_cron","text":"register_cron( fn: Callable[[], None], interval: datetime.timedelta) \u2011> None Registers a cron task to run at a specified interval. Calling this function alone will not do anything. In order to run pending cron tasks, you must call run_pending_cron_tasks (the included management task run_pending_cron_tasks will do this for you on a loop) Parameters fn Function implementing the cron task. interval Interval to run the cron task at.","title":"register_cron"},{"location":"api/groundwork.core.cron/#run_pending_cron_tasks","text":"run_pending_cron_tasks( all: bool = False) \u2011> None Runs all pending cron tasks then returns. You usually won't want to call this \u2013 unless yu are implementing a custom clock process. In general, you'll want the management command run_pending_cron_tasks , which calls this for you on a loop. Parameters all Run all tasks regardless of whether they're scheduled","title":"run_pending_cron_tasks"},{"location":"api/groundwork.core.datasources/","text":"import groundwork.core.datasources Datasource Abstract interface for reading from an external resource. For most REST APIs, unless you are wrapping an existing client library, you probably want to use the subclass ApiClient instead of this class. Subclasses: groundwork.core.datasources.MockDatasource groundwork.core.datasources.RestDatasource Constructor : Datasource(**kwargs) Class variables identifer str An attribute of ResourceT that will re-fetch the resource when passed to get() . This will usually be id and that is the default. resource_type Type[~ResourceT] Class that API responses should be deserialized into. MockDatasource Simple in-memory datasource useful for stubbing out remote APIs in tests. Inherits: groundwork.core.datasources.Datasource Constructor : MockDatasource(data: List[~ResourceT], identifer: str = 'id', **kwargs: Any) RestDatasource Base class for implementing Rest API clients and converting their responses to resource objects. Responses are validated using a django-rest Serializer to ensure that the returned data matches the types declared on the resource type. You are encouraged to use Python's inbuilt @dataclass decorator and define type hints when defining these classes as this allows type-safe serializers to be auto-generated and decreases the amount of boilerplate code that you need to write. Provides reasonable default behaviour for get and list operations. You will likely want to subclass this for each external service to acommodate differing behaviours around things like pagination. Class variables can all either be provided as keyword-args to the constructor, or overridden in subclasses. Conforms to the Datasource interface, so instances of APIClient can be provided to SyncedModel s as their datasource. Inherits: groundwork.core.datasources.Datasource Subclasses: groundwork.contrib.airtable.datasources.AirtableDatasource Constructor : RestDatasource(**kwargs: Dict[str, Any]) Class variables base_url str Base API url prepended to path to produce the full endpoint url. Can be overridden in subclasses or provided as a kwarg to the initializer. filter Optional[Callable[[~ResourceT], bool]] Filter returned resources to those matching this predicate. Can be overridden in subclasses or provided as a kwarg to the initializer. parser_class Type[rest_framework.parsers.BaseParser] A django-rest parser used to parse API responses for processing by the serializer. Can be overridden in subclasses or provided as a kwarg to the initializer. If not provided, assumes you are dealing with json API responses using the same 'snake_case' conventions as Python attribute names. path str Prepended to base_url to produce the full endpoint url. Can be overridden in subclasses or provided as a kwarg to the initializer. serializer_class Type[rest_framework.serializers.Serializer] A django-rest serializer used to deserialize API responses into instances of the dataclass. Can be overridden in subclasses or provided as a kwarg to the initializer. If not provided, a serializer is generated from the class provided in resource_type . You only need to provide a serializer if the resource type is not decorated with the @dataclass decorator, or you have custom serialization requirements. Instance variables url str Methods deserialize deserialize( self, data: Any) \u2011> ~ResourceT Deserialize raw data representation returned by the API into an instance of resource_type. Override this for advanced customization of resource deserialization. You will rarely need to do this as it is generally easier to provide a custom serializer_class The default implementation validates and returns a deserialized instance by calling through to deserializer_class . Parameters data Raw (parsed but still serialized) data representation of the remote resource. Raises TypeError If validating the returned data fails. Returns An instance of this resource's resource_type type. fetch_url fetch_url( self, url: str, query: Dict[str, Any]) \u2011> Any Get a resource by URL and return its raw (parsed but not deserialized) response data. Override this to customize how HTTP GET requests are made. The list() method will The default implementation validates that the request is successful then parses the response data using parser_class . Parameters url URL of the fetched resource query Query params passed to the GET request. Raises OSError If the server response does not have a 2xx status code. Returns Raw (parsed but still serialized) data representation of the remote resource identified by url . get get( self, id: str, **kwargs: Dict[str, Any]) \u2011> ~ResourceT Get a resource by id, deserialize to the resource_type and return. The default implementation creates the resource url by appending the id to the endpoint url. Parameters id External identifier for the fetched resource **kwargs Query params passed to the API call. Returns A resource instance representing the remote datasource. get_headers get_headers( self) \u2011> Dict[str, str] Headers to add to requests. Defaults implementation returns none. Returns Dictionary of headers list list( self, **kwargs: Dict[str, Any]) \u2011> Iterable[~ResourceT] List, or search. The default implementation creates the resource url by appending the id to the endpoint url. Parameters **kwargs Query params passed to the API call. Yields Resource instances representing the remote datasource. paginate paginate( self, **query: Dict[str, Any]) \u2011> Iterable[~ResourceT] List this resource and return an iterable of raw representations. Override to customize how list() calls are paginated between or the url is constructed. If you override this to support pagination, you should yield instances rather than returning a list. The default implementation does not perform pagination \u2013 it expects the response data to be a simple list of resources. Parameters query Query params passed to the GET request. Yields Raw (parsed but still serialized) resource objects. SyncConfig Config object defining how subclasses of SyncedModel sync with an external datasource. Properties All properties are valid as keyword-args to the constructor. They are required unless marked optional below. datasource Datasource [typing.Any] External resource to periodically sync this model with external_id str Field on both the external resource and this model that is used to map values returned from the external service onto instances of the model. field_map Optional[Dict[str, str]] Map from fields in the model to fields in the external resource. sync_interval Optional[datetime.timedelta] Frequency with which the model should be synced from the external source. Defaults to one day. If set to None , this model will never refresh itself from the external source and only populate when referenced by another synced model, or sync() is explicitly called. SyncedModel Base class for models are fetched on a schedule from a remote data source. Models that subclass this class must declare a sync_config attribute, which configures the remote resource to pull from and how to merge it into the database. Constructor : SyncedModel(*args, **kwargs) Class variables sync_config SyncConfig Configuration object defining the datasource and how to sync it. Required for all non-abstract subclasses. Instance variables id SyncedModels need to have a uuid primary key to handle recursive references when syncing. last_sync_time Last time this resource was updated from the datasource. Static methods sync sync( ) Synchronizes the class immediately.","title":"Data sources"},{"location":"api/groundwork.core.datasources/#datasource","text":"Abstract interface for reading from an external resource. For most REST APIs, unless you are wrapping an existing client library, you probably want to use the subclass ApiClient instead of this class. Subclasses: groundwork.core.datasources.MockDatasource groundwork.core.datasources.RestDatasource Constructor : Datasource(**kwargs)","title":"Datasource"},{"location":"api/groundwork.core.datasources/#class-variables","text":"","title":"Class variables"},{"location":"api/groundwork.core.datasources/#identifer","text":"str An attribute of ResourceT that will re-fetch the resource when passed to get() . This will usually be id and that is the default.","title":"identifer"},{"location":"api/groundwork.core.datasources/#resource_type","text":"Type[~ResourceT] Class that API responses should be deserialized into.","title":"resource_type"},{"location":"api/groundwork.core.datasources/#mockdatasource","text":"Simple in-memory datasource useful for stubbing out remote APIs in tests. Inherits: groundwork.core.datasources.Datasource Constructor : MockDatasource(data: List[~ResourceT], identifer: str = 'id', **kwargs: Any)","title":"MockDatasource"},{"location":"api/groundwork.core.datasources/#restdatasource","text":"Base class for implementing Rest API clients and converting their responses to resource objects. Responses are validated using a django-rest Serializer to ensure that the returned data matches the types declared on the resource type. You are encouraged to use Python's inbuilt @dataclass decorator and define type hints when defining these classes as this allows type-safe serializers to be auto-generated and decreases the amount of boilerplate code that you need to write. Provides reasonable default behaviour for get and list operations. You will likely want to subclass this for each external service to acommodate differing behaviours around things like pagination. Class variables can all either be provided as keyword-args to the constructor, or overridden in subclasses. Conforms to the Datasource interface, so instances of APIClient can be provided to SyncedModel s as their datasource. Inherits: groundwork.core.datasources.Datasource Subclasses: groundwork.contrib.airtable.datasources.AirtableDatasource Constructor : RestDatasource(**kwargs: Dict[str, Any])","title":"RestDatasource"},{"location":"api/groundwork.core.datasources/#class-variables_1","text":"","title":"Class variables"},{"location":"api/groundwork.core.datasources/#base_url","text":"str Base API url prepended to path to produce the full endpoint url. Can be overridden in subclasses or provided as a kwarg to the initializer.","title":"base_url"},{"location":"api/groundwork.core.datasources/#filter","text":"Optional[Callable[[~ResourceT], bool]] Filter returned resources to those matching this predicate. Can be overridden in subclasses or provided as a kwarg to the initializer.","title":"filter"},{"location":"api/groundwork.core.datasources/#parser_class","text":"Type[rest_framework.parsers.BaseParser] A django-rest parser used to parse API responses for processing by the serializer. Can be overridden in subclasses or provided as a kwarg to the initializer. If not provided, assumes you are dealing with json API responses using the same 'snake_case' conventions as Python attribute names.","title":"parser_class"},{"location":"api/groundwork.core.datasources/#path","text":"str Prepended to base_url to produce the full endpoint url. Can be overridden in subclasses or provided as a kwarg to the initializer.","title":"path"},{"location":"api/groundwork.core.datasources/#serializer_class","text":"Type[rest_framework.serializers.Serializer] A django-rest serializer used to deserialize API responses into instances of the dataclass. Can be overridden in subclasses or provided as a kwarg to the initializer. If not provided, a serializer is generated from the class provided in resource_type . You only need to provide a serializer if the resource type is not decorated with the @dataclass decorator, or you have custom serialization requirements.","title":"serializer_class"},{"location":"api/groundwork.core.datasources/#instance-variables","text":"","title":"Instance variables"},{"location":"api/groundwork.core.datasources/#url","text":"str","title":"url"},{"location":"api/groundwork.core.datasources/#methods","text":"","title":"Methods"},{"location":"api/groundwork.core.datasources/#deserialize","text":"deserialize( self, data: Any) \u2011> ~ResourceT Deserialize raw data representation returned by the API into an instance of resource_type. Override this for advanced customization of resource deserialization. You will rarely need to do this as it is generally easier to provide a custom serializer_class The default implementation validates and returns a deserialized instance by calling through to deserializer_class . Parameters data Raw (parsed but still serialized) data representation of the remote resource. Raises TypeError If validating the returned data fails. Returns An instance of this resource's resource_type type.","title":"deserialize"},{"location":"api/groundwork.core.datasources/#fetch_url","text":"fetch_url( self, url: str, query: Dict[str, Any]) \u2011> Any Get a resource by URL and return its raw (parsed but not deserialized) response data. Override this to customize how HTTP GET requests are made. The list() method will The default implementation validates that the request is successful then parses the response data using parser_class . Parameters url URL of the fetched resource query Query params passed to the GET request. Raises OSError If the server response does not have a 2xx status code. Returns Raw (parsed but still serialized) data representation of the remote resource identified by url .","title":"fetch_url"},{"location":"api/groundwork.core.datasources/#get","text":"get( self, id: str, **kwargs: Dict[str, Any]) \u2011> ~ResourceT Get a resource by id, deserialize to the resource_type and return. The default implementation creates the resource url by appending the id to the endpoint url. Parameters id External identifier for the fetched resource **kwargs Query params passed to the API call. Returns A resource instance representing the remote datasource.","title":"get"},{"location":"api/groundwork.core.datasources/#get_headers","text":"get_headers( self) \u2011> Dict[str, str] Headers to add to requests. Defaults implementation returns none. Returns Dictionary of headers","title":"get_headers"},{"location":"api/groundwork.core.datasources/#list","text":"list( self, **kwargs: Dict[str, Any]) \u2011> Iterable[~ResourceT] List, or search. The default implementation creates the resource url by appending the id to the endpoint url. Parameters **kwargs Query params passed to the API call. Yields Resource instances representing the remote datasource.","title":"list"},{"location":"api/groundwork.core.datasources/#paginate","text":"paginate( self, **query: Dict[str, Any]) \u2011> Iterable[~ResourceT] List this resource and return an iterable of raw representations. Override to customize how list() calls are paginated between or the url is constructed. If you override this to support pagination, you should yield instances rather than returning a list. The default implementation does not perform pagination \u2013 it expects the response data to be a simple list of resources. Parameters query Query params passed to the GET request. Yields Raw (parsed but still serialized) resource objects.","title":"paginate"},{"location":"api/groundwork.core.datasources/#syncconfig","text":"Config object defining how subclasses of SyncedModel sync with an external datasource.","title":"SyncConfig"},{"location":"api/groundwork.core.datasources/#properties","text":"All properties are valid as keyword-args to the constructor. They are required unless marked optional below.","title":"Properties"},{"location":"api/groundwork.core.datasources/#datasource_1","text":"Datasource [typing.Any] External resource to periodically sync this model with","title":"datasource"},{"location":"api/groundwork.core.datasources/#external_id","text":"str Field on both the external resource and this model that is used to map values returned from the external service onto instances of the model.","title":"external_id"},{"location":"api/groundwork.core.datasources/#field_map","text":"Optional[Dict[str, str]] Map from fields in the model to fields in the external resource.","title":"field_map"},{"location":"api/groundwork.core.datasources/#sync_interval","text":"Optional[datetime.timedelta] Frequency with which the model should be synced from the external source. Defaults to one day. If set to None , this model will never refresh itself from the external source and only populate when referenced by another synced model, or sync() is explicitly called.","title":"sync_interval"},{"location":"api/groundwork.core.datasources/#syncedmodel","text":"Base class for models are fetched on a schedule from a remote data source. Models that subclass this class must declare a sync_config attribute, which configures the remote resource to pull from and how to merge it into the database. Constructor : SyncedModel(*args, **kwargs)","title":"SyncedModel"},{"location":"api/groundwork.core.datasources/#class-variables_2","text":"","title":"Class variables"},{"location":"api/groundwork.core.datasources/#sync_config","text":"SyncConfig Configuration object defining the datasource and how to sync it. Required for all non-abstract subclasses.","title":"sync_config"},{"location":"api/groundwork.core.datasources/#instance-variables_1","text":"","title":"Instance variables"},{"location":"api/groundwork.core.datasources/#id","text":"SyncedModels need to have a uuid primary key to handle recursive references when syncing.","title":"id"},{"location":"api/groundwork.core.datasources/#last_sync_time","text":"Last time this resource was updated from the datasource.","title":"last_sync_time"},{"location":"api/groundwork.core.datasources/#static-methods","text":"","title":"Static methods"},{"location":"api/groundwork.core.datasources/#sync","text":"sync( ) Synchronizes the class immediately.","title":"sync"},{"location":"api/groundwork.core.internal.asset_loader/","text":"import groundwork.core.internal.asset_loader Utilities for loading the built assets bundled with the python package. Adatpted from django-vite package, modified to accomodate the fact that it's being distributed with a library. GroundworkAssetLoader Class handling Vite asset loading. Constructor : GroundworkAssetLoader() Static methods generate_vite_ws_client generate_vite_ws_client( ) \u2011> str Generates the script tag for the Vite WS client for HMR. Only used in development, in production this method returns an empty string. Returns The script tag or an empty string. instance instance( ) Singleton. Uses singleton to keep parsed manifest in memory after the first time it's loaded. Returns only instance of the class. Methods generate_dynamic_handlers generate_dynamic_handlers( self) \u2011> str Generates a","title":"Groundwork.core.internal.asset loader"},{"location":"api/groundwork.core.internal.asset_loader/#groundworkassetloader","text":"Class handling Vite asset loading. Constructor : GroundworkAssetLoader()","title":"GroundworkAssetLoader"},{"location":"api/groundwork.core.internal.asset_loader/#static-methods","text":"","title":"Static methods"},{"location":"api/groundwork.core.internal.asset_loader/#generate_vite_ws_client","text":"generate_vite_ws_client( ) \u2011> str Generates the script tag for the Vite WS client for HMR. Only used in development, in production this method returns an empty string. Returns The script tag or an empty string.","title":"generate_vite_ws_client"},{"location":"api/groundwork.core.internal.asset_loader/#instance","text":"instance( ) Singleton. Uses singleton to keep parsed manifest in memory after the first time it's loaded. Returns only instance of the class.","title":"instance"},{"location":"api/groundwork.core.internal.asset_loader/#methods","text":"","title":"Methods"},{"location":"api/groundwork.core.internal.asset_loader/#generate_dynamic_handlers","text":"generate_dynamic_handlers( self) \u2011> str Generates a","title":"generate_dynamic_handlers"},{"location":"api/groundwork.core.internal.class_util/","text":"import groundwork.core.internal.class_util get_superclass_of_type get_superclass_of_type( cls: Type[Any], superclass: Type[Any]) \u2011> Optional[Type[Any]] Return the first class in a class' method resolution order (other than itself) that is a subclass of a specified type. Parameters cls The subclass to search the resolution order of. superclass The class that the returned value should descend from. Returns The matching superclass, or None if none was found. mixin_classes mixin_classes( *classlist) Create a new class inheriting from classlist in the specified order. Useful for allowing configuration classes on models to inherit from the configuration classes of the model's superclass. Parameters classlist The list of classes to merge together. Returns A new class mixing parents in as supeclasses of cls1 .","title":"Groundwork.core.internal.class util"},{"location":"api/groundwork.core.internal.class_util/#get_superclass_of_type","text":"get_superclass_of_type( cls: Type[Any], superclass: Type[Any]) \u2011> Optional[Type[Any]] Return the first class in a class' method resolution order (other than itself) that is a subclass of a specified type. Parameters cls The subclass to search the resolution order of. superclass The class that the returned value should descend from. Returns The matching superclass, or None if none was found.","title":"get_superclass_of_type"},{"location":"api/groundwork.core.internal.class_util/#mixin_classes","text":"mixin_classes( *classlist) Create a new class inheriting from classlist in the specified order. Useful for allowing configuration classes on models to inherit from the configuration classes of the model's superclass. Parameters classlist The list of classes to merge together. Returns A new class mixing parents in as supeclasses of cls1 .","title":"mixin_classes"},{"location":"api/groundwork.core.internal.collection_util/","text":"import groundwork.core.internal.collection_util compact_values compact_values( dictlike: Iterable[Tuple[~KeyT, ~ValT]]) \u2011> Iterable[Tuple[~KeyT, ~ValT]]","title":"Groundwork.core.internal.collection util"},{"location":"api/groundwork.core.internal.collection_util/#compact_values","text":"compact_values( dictlike: Iterable[Tuple[~KeyT, ~ValT]]) \u2011> Iterable[Tuple[~KeyT, ~ValT]]","title":"compact_values"},{"location":"api/groundwork.core.internal/","text":"import groundwork.core.internal groundwork.core.internal.asset_loader groundwork.core.internal.class_util groundwork.core.internal.collection_util groundwork.core.internal.sync_manager","title":"Groundwork.core.internal"},{"location":"api/groundwork.core.internal.sync_manager/","text":"import groundwork.core.internal.sync_manager ModelSyncState ModelSyncState(resolved_instances: Dict[str, Any] = ) Properties All properties are valid as keyword-args to the constructor. They are required unless marked optional below. resolved_instances Dict[str, Any] SyncManager Manages the synchronisation logic for pulling all instances of a remote datasource. Due to sometimes needing to recurse through referenced models, a synchronisation session is stateful. Constructor : SyncManager() Methods fetch_urlsource_field_key fetch_urlsource_field_key( cls, model: Type[ SyncedModel ], model_key: str) \u2011> Optional[str] Return the datasource key for a given model key. Parameters model The model class that the field is being mapped to. model_key The field that we wish to update the value of. Returns The key to look up on the resource to assign to the model. prepare_attr_field_for_save prepare_attr_field_for_save( self, model: Type[ SyncedModel ], field: django.db.models.fields.Field, resource: Any) \u2011> Optional[Any] Given a value returned by the datasource, convert it into a value suitable for saving locally into the field represented by field . The default implementation returns the value as-is unless the field is a foreign key, in which case the value is assumed to be an external identifier and the referenced local instance is returned, fetching it from the datasource and saving if needed. Many-to-many relationships are ignored and handled separately as then can't be applied to a model before it is saved. Parameters model The model class detailing how the attributes of resource are to be treated. field The field descriptor that we wish to update the value of. resource A resource returned by the datasource. Returns A value suitable for saving in the slot identified by field . Or None if no value is suitable. prepare_m2m_field_for_save prepare_m2m_field_for_save( self, model: Type[ SyncedModel ], field: django.db.models.fields.Field, resource: Any) \u2011> Any Given a list of external ids returned by the remote datasource, resolve the external ids into the local model (fetching from remote if needed) and return the new list of related values. Parameters model The model class detailing how the attributes of resource are to be treated. field The field descriptor that we wish to update the value of. resource A resource returned by the datasource. Returns A list of model instances suitable for assigning to the m2m relationship, or None if this is not an m2m relationship that we need to update. prepare_resource_attrs_for_save prepare_resource_attrs_for_save( self, model: Type[ SyncedModel ], resource: Any) \u2011> Dict[str, Any] Given an object returned by the datasource, prepare it for saving to the database. The default implementation: - Strips from each resource any fields not present in the model. - Prepares each attribute by calling prepare_field_for_save . - Updates the last_sync_time attribute with the current date & time. Parameters model The model class detailing how the attributes of resource are to be treated. resource A resource returned by the datasource. Returns A dictionary of properties suitable for assigning to an instance of model . resolve_by_external_id resolve_by_external_id( self, model: Type[ SyncedModel ], id: Any) \u2011> Any Given the external id for an instance of a model class, either: If the instance has already been synced, return it. If the instance has not yet been synced, fetch it from the datasource, save a local copy and return that. Parameters model The model class to resolve into. This model's sync config will be used to fetch the resource if needed. id Identifier used to fetch the resource fron the datasource. Returns The local model representation of the resource identified by id . resove_embedded_value resove_embedded_value( self, model: Type[ SyncedModel ], resource: Any) \u2011> Any Given a resorce object, get or create a model representation for it and return it, updating from the resource if needed. Parameters model The model class to resolve into. resource The resource instance to convert to a model. Returns Local model representation of the resource, saved in the database. set_resource_m2m set_resource_m2m( self, model: Type[ SyncedModel ], resource: Any, instance: Any) \u2011> None Given an object returned by the datasource and the local model representing it, apply the m2m relationships in the resource. Parameters model The model class detailing how the attributes of resource are to be treated. resource A resource returned by the datasource. instance The local model instance to update the m2m relationships of. sync_model sync_model( self, model: Type[ SyncedModel ]) \u2011> None Pull the result of calling list() on a SyncedModel 's datasource into the local database. Recursively resolves relationships to other SyncedModels. Parameters model The model class to sync from its datasource.","title":"Groundwork.core.internal.sync manager"},{"location":"api/groundwork.core.internal.sync_manager/#modelsyncstate","text":"ModelSyncState(resolved_instances: Dict[str, Any] = )","title":"ModelSyncState"},{"location":"api/groundwork.core.internal.sync_manager/#properties","text":"All properties are valid as keyword-args to the constructor. They are required unless marked optional below.","title":"Properties"},{"location":"api/groundwork.core.internal.sync_manager/#resolved_instances","text":"Dict[str, Any]","title":"resolved_instances"},{"location":"api/groundwork.core.internal.sync_manager/#syncmanager","text":"Manages the synchronisation logic for pulling all instances of a remote datasource. Due to sometimes needing to recurse through referenced models, a synchronisation session is stateful. Constructor : SyncManager()","title":"SyncManager"},{"location":"api/groundwork.core.internal.sync_manager/#methods","text":"","title":"Methods"},{"location":"api/groundwork.core.internal.sync_manager/#fetch_urlsource_field_key","text":"fetch_urlsource_field_key( cls, model: Type[ SyncedModel ], model_key: str) \u2011> Optional[str] Return the datasource key for a given model key. Parameters model The model class that the field is being mapped to. model_key The field that we wish to update the value of. Returns The key to look up on the resource to assign to the model.","title":"fetch_urlsource_field_key"},{"location":"api/groundwork.core.internal.sync_manager/#prepare_attr_field_for_save","text":"prepare_attr_field_for_save( self, model: Type[ SyncedModel ], field: django.db.models.fields.Field, resource: Any) \u2011> Optional[Any] Given a value returned by the datasource, convert it into a value suitable for saving locally into the field represented by field . The default implementation returns the value as-is unless the field is a foreign key, in which case the value is assumed to be an external identifier and the referenced local instance is returned, fetching it from the datasource and saving if needed. Many-to-many relationships are ignored and handled separately as then can't be applied to a model before it is saved. Parameters model The model class detailing how the attributes of resource are to be treated. field The field descriptor that we wish to update the value of. resource A resource returned by the datasource. Returns A value suitable for saving in the slot identified by field . Or None if no value is suitable.","title":"prepare_attr_field_for_save"},{"location":"api/groundwork.core.internal.sync_manager/#prepare_m2m_field_for_save","text":"prepare_m2m_field_for_save( self, model: Type[ SyncedModel ], field: django.db.models.fields.Field, resource: Any) \u2011> Any Given a list of external ids returned by the remote datasource, resolve the external ids into the local model (fetching from remote if needed) and return the new list of related values. Parameters model The model class detailing how the attributes of resource are to be treated. field The field descriptor that we wish to update the value of. resource A resource returned by the datasource. Returns A list of model instances suitable for assigning to the m2m relationship, or None if this is not an m2m relationship that we need to update.","title":"prepare_m2m_field_for_save"},{"location":"api/groundwork.core.internal.sync_manager/#prepare_resource_attrs_for_save","text":"prepare_resource_attrs_for_save( self, model: Type[ SyncedModel ], resource: Any) \u2011> Dict[str, Any] Given an object returned by the datasource, prepare it for saving to the database. The default implementation: - Strips from each resource any fields not present in the model. - Prepares each attribute by calling prepare_field_for_save . - Updates the last_sync_time attribute with the current date & time. Parameters model The model class detailing how the attributes of resource are to be treated. resource A resource returned by the datasource. Returns A dictionary of properties suitable for assigning to an instance of model .","title":"prepare_resource_attrs_for_save"},{"location":"api/groundwork.core.internal.sync_manager/#resolve_by_external_id","text":"resolve_by_external_id( self, model: Type[ SyncedModel ], id: Any) \u2011> Any Given the external id for an instance of a model class, either: If the instance has already been synced, return it. If the instance has not yet been synced, fetch it from the datasource, save a local copy and return that. Parameters model The model class to resolve into. This model's sync config will be used to fetch the resource if needed. id Identifier used to fetch the resource fron the datasource. Returns The local model representation of the resource identified by id .","title":"resolve_by_external_id"},{"location":"api/groundwork.core.internal.sync_manager/#resove_embedded_value","text":"resove_embedded_value( self, model: Type[ SyncedModel ], resource: Any) \u2011> Any Given a resorce object, get or create a model representation for it and return it, updating from the resource if needed. Parameters model The model class to resolve into. resource The resource instance to convert to a model. Returns Local model representation of the resource, saved in the database.","title":"resove_embedded_value"},{"location":"api/groundwork.core.internal.sync_manager/#set_resource_m2m","text":"set_resource_m2m( self, model: Type[ SyncedModel ], resource: Any, instance: Any) \u2011> None Given an object returned by the datasource and the local model representing it, apply the m2m relationships in the resource. Parameters model The model class detailing how the attributes of resource are to be treated. resource A resource returned by the datasource. instance The local model instance to update the m2m relationships of.","title":"set_resource_m2m"},{"location":"api/groundwork.core.internal.sync_manager/#sync_model","text":"sync_model( self, model: Type[ SyncedModel ]) \u2011> None Pull the result of calling list() on a SyncedModel 's datasource into the local database. Recursively resolves relationships to other SyncedModels. Parameters model The model class to sync from its datasource.","title":"sync_model"},{"location":"api/groundwork.core.management.commands/","text":"import groundwork.core.management.commands groundwork.core.management.commands.run_cron_tasks","title":"Groundwork.core.management.commands"},{"location":"api/groundwork.core.management.commands.run_cron_tasks/","text":"import groundwork.core.management.commands.run_cron_tasks Command The base class from which all management commands ultimately derive. Use this class if you want access to all of the mechanisms which parse the command-line arguments and work out what code to call in response; if you don't need to change any of that behavior, consider using one of the subclasses defined in this file. If you are interested in overriding/customizing various aspects of the command-parsing and -execution behavior, the normal flow works as follows: django-admin or manage.py loads the command class and calls its run_from_argv() method. The run_from_argv() method calls create_parser() to get an ArgumentParser for the arguments, parses them, performs any environment changes requested by options like pythonpath , and then calls the execute() method, passing the parsed arguments. The execute() method attempts to carry out the command by calling the handle() method with the parsed arguments; any output produced by handle() will be printed to standard output and, if the command is intended to produce a block of SQL statements, will be wrapped in BEGIN and COMMIT . If handle() or execute() raised any exception (e.g. CommandError ), run_from_argv() will instead print an error message to stderr . Thus, the handle() method is typically the starting point for subclasses; many built-in commands and command types either place all of their logic in handle() , or perform some additional parsing work in handle() and then delegate from it to more specialized methods as needed. Several attributes affect behavior at various steps along the way: help A short description of the command, which will be printed in help messages. output_transaction A boolean indicating whether the command outputs SQL statements; if True , the output will automatically be wrapped with BEGIN; and COMMIT; . Default value is False . requires_migrations_checks A boolean; if True , the command prints a warning if the set of migrations on disk don't match the migrations in the database. requires_system_checks A list or tuple of tags, e.g. [Tags.staticfiles, Tags.models]. System checks registered in the chosen tags will be checked for errors prior to executing the command. The value ' all ' can be used to specify that all system checks should be performed. Default value is ' all '. To validate an individual application's models rather than all applications' models, call ``self.check(app_configs)`` from ``handle()``, where ``app_configs`` is the list of application's configuration provided by the app registry. stealth_options A tuple of any options the command uses which aren't defined by the argument parser. Constructor : Command(stdout=None, stderr=None, no_color=False, force_color=False) Methods add_arguments add_arguments( self, parser: django.core.management.base.CommandParser) \u2011> None Entry point for subclassed commands to add custom arguments. handle handle( self, *args, once, **options) The actual logic of the command. Subclasses must implement this method.","title":"Groundwork.core.management.commands.run cron tasks"},{"location":"api/groundwork.core.management.commands.run_cron_tasks/#command","text":"The base class from which all management commands ultimately derive. Use this class if you want access to all of the mechanisms which parse the command-line arguments and work out what code to call in response; if you don't need to change any of that behavior, consider using one of the subclasses defined in this file. If you are interested in overriding/customizing various aspects of the command-parsing and -execution behavior, the normal flow works as follows: django-admin or manage.py loads the command class and calls its run_from_argv() method. The run_from_argv() method calls create_parser() to get an ArgumentParser for the arguments, parses them, performs any environment changes requested by options like pythonpath , and then calls the execute() method, passing the parsed arguments. The execute() method attempts to carry out the command by calling the handle() method with the parsed arguments; any output produced by handle() will be printed to standard output and, if the command is intended to produce a block of SQL statements, will be wrapped in BEGIN and COMMIT . If handle() or execute() raised any exception (e.g. CommandError ), run_from_argv() will instead print an error message to stderr . Thus, the handle() method is typically the starting point for subclasses; many built-in commands and command types either place all of their logic in handle() , or perform some additional parsing work in handle() and then delegate from it to more specialized methods as needed. Several attributes affect behavior at various steps along the way: help A short description of the command, which will be printed in help messages. output_transaction A boolean indicating whether the command outputs SQL statements; if True , the output will automatically be wrapped with BEGIN; and COMMIT; . Default value is False . requires_migrations_checks A boolean; if True , the command prints a warning if the set of migrations on disk don't match the migrations in the database. requires_system_checks A list or tuple of tags, e.g. [Tags.staticfiles, Tags.models]. System checks registered in the chosen tags will be checked for errors prior to executing the command. The value ' all ' can be used to specify that all system checks should be performed. Default value is ' all '. To validate an individual application's models rather than all applications' models, call ``self.check(app_configs)`` from ``handle()``, where ``app_configs`` is the list of application's configuration provided by the app registry. stealth_options A tuple of any options the command uses which aren't defined by the argument parser. Constructor : Command(stdout=None, stderr=None, no_color=False, force_color=False)","title":"Command"},{"location":"api/groundwork.core.management.commands.run_cron_tasks/#methods","text":"","title":"Methods"},{"location":"api/groundwork.core.management.commands.run_cron_tasks/#add_arguments","text":"add_arguments( self, parser: django.core.management.base.CommandParser) \u2011> None Entry point for subclassed commands to add custom arguments.","title":"add_arguments"},{"location":"api/groundwork.core.management.commands.run_cron_tasks/#handle","text":"handle( self, *args, once, **options) The actual logic of the command. Subclasses must implement this method.","title":"handle"},{"location":"api/groundwork.core.management/","text":"import groundwork.core.management groundwork.core.management.commands","title":"Groundwork.core.management"},{"location":"api/groundwork.core/","text":"import groundwork.core groundwork.core.cache groundwork.core.cron groundwork.core.datasources groundwork.core.internal groundwork.core.management groundwork.core.template groundwork.core.templatetags groundwork.core.types","title":"Groundwork.core"},{"location":"api/groundwork.core.template/","text":"import groundwork.core.template register_block_tag register_block_tag( library: django.template.library.Library, takes_context: Optional[bool] = None, upto: Optional[bool] = None, name: Optional[str] = None) \u2011> Callable[[~_T], ~_T] Helper for creating and registering a template tag that contains a block of html and accepts args and kwargs similarly to the @simple_tag decorator. Wrap a callable in a parser, passing its args and kwargs to the wrapped callable, along with its content nodelist as the children kwarg. The implementation is identical to Django's inbuilt Library.simple_tag, except that it continues to parse up to an end marker. Parameters library The tags library to register the tag with. takes_context Whether the tag accepts its parent context. Note that the block's content always receives its parent context. If provided, the decorated function must have context as its first parameter. name The name of the template tag. Defaults to the function name. upto Override the tag signifying the end of the html block. Defaults to \"end\" prepended to the tag name. Returns A decorator that can be used similarly to @simple_tag","title":"Template utils"},{"location":"api/groundwork.core.template/#register_block_tag","text":"register_block_tag( library: django.template.library.Library, takes_context: Optional[bool] = None, upto: Optional[bool] = None, name: Optional[str] = None) \u2011> Callable[[~_T], ~_T] Helper for creating and registering a template tag that contains a block of html and accepts args and kwargs similarly to the @simple_tag decorator. Wrap a callable in a parser, passing its args and kwargs to the wrapped callable, along with its content nodelist as the children kwarg. The implementation is identical to Django's inbuilt Library.simple_tag, except that it continues to parse up to an end marker. Parameters library The tags library to register the tag with. takes_context Whether the tag accepts its parent context. Note that the block's content always receives its parent context. If provided, the decorated function must have context as its first parameter. name The name of the template tag. Defaults to the function name. upto Override the tag signifying the end of the html block. Defaults to \"end\" prepended to the tag name. Returns A decorator that can be used similarly to @simple_tag","title":"register_block_tag"},{"location":"api/groundwork.core.templatetags.groundwork_core/","text":"import groundwork.core.templatetags.groundwork_core groundwork_static groundwork_static( )","title":"Groundwork.core.templatetags.groundwork core"},{"location":"api/groundwork.core.templatetags.groundwork_core/#groundwork_static","text":"groundwork_static( )","title":"groundwork_static"},{"location":"api/groundwork.core.templatetags/","text":"import groundwork.core.templatetags groundwork.core.templatetags.groundwork_core","title":"Groundwork.core.templatetags"},{"location":"api/groundwork.core.types/","text":"import groundwork.core.types","title":"Groundwork.core.types"},{"location":"api/groundwork.geo.examples/","text":"import groundwork.geo.examples MapExampleView Render a template. Pass keyword arguments from the URLconf to the context. Constructor. Called in the URLconf; can contain helpful extra keyword arguments, and other things. Constructor : MapExampleView(**kwargs) Instance variables layers sources","title":"Groundwork.geo.examples"},{"location":"api/groundwork.geo.examples/#mapexampleview","text":"Render a template. Pass keyword arguments from the URLconf to the context. Constructor. Called in the URLconf; can contain helpful extra keyword arguments, and other things. Constructor : MapExampleView(**kwargs)","title":"MapExampleView"},{"location":"api/groundwork.geo.examples/#instance-variables","text":"","title":"Instance variables"},{"location":"api/groundwork.geo.examples/#layers","text":"","title":"layers"},{"location":"api/groundwork.geo.examples/#sources","text":"","title":"sources"},{"location":"api/groundwork.geo/","text":"import groundwork.geo groundwork.geo.examples groundwork.geo.templatetags groundwork.geo.territories","title":"Groundwork.geo"},{"location":"api/groundwork.geo.templatetags.groundwork_geo/","text":"import groundwork.geo.templatetags.groundwork_geo map map( context: Any, element: str = 'div', style: Optional[str] = None, api_key: Optional[str] = None, center: Any = None, zoom: Optional[int] = None, in_place: Optional[bool] = True, children: Optional[django.template.base.NodeList] = None, **attrs: Dict[str, str]) \u2011> django.template.base.Node map_canvas map_canvas( element: str = 'div', **attrs: Dict[str, str]) map_layer map_layer( id, layer) map_source map_source( id, data)","title":"Groundwork.geo.templatetags.groundwork geo"},{"location":"api/groundwork.geo.templatetags.groundwork_geo/#map","text":"map( context: Any, element: str = 'div', style: Optional[str] = None, api_key: Optional[str] = None, center: Any = None, zoom: Optional[int] = None, in_place: Optional[bool] = True, children: Optional[django.template.base.NodeList] = None, **attrs: Dict[str, str]) \u2011> django.template.base.Node","title":"map"},{"location":"api/groundwork.geo.templatetags.groundwork_geo/#map_canvas","text":"map_canvas( element: str = 'div', **attrs: Dict[str, str])","title":"map_canvas"},{"location":"api/groundwork.geo.templatetags.groundwork_geo/#map_layer","text":"map_layer( id, layer)","title":"map_layer"},{"location":"api/groundwork.geo.templatetags.groundwork_geo/#map_source","text":"map_source( id, data)","title":"map_source"},{"location":"api/groundwork.geo.templatetags/","text":"import groundwork.geo.templatetags groundwork.geo.templatetags.groundwork_geo","title":"Groundwork.geo.templatetags"},{"location":"api/groundwork.geo.territories/","text":"import groundwork.geo.territories groundwork.geo.territories.uk","title":"Groundwork.geo.territories"},{"location":"api/groundwork.geo.territories.uk.internal/","text":"import groundwork.geo.territories.uk.internal groundwork.geo.territories.uk.internal.serializers","title":"Groundwork.geo.territories.uk.internal"},{"location":"api/groundwork.geo.territories.uk.internal.serializers/","text":"import groundwork.geo.territories.uk.internal.serializers embedded_value embedded_value( dataclass: Type[Any]) \u2011> dataclasses.Field Convenience function for returning a dataclass field descriptor that informs DataclassSerializer that we wish to use the EmbeddedValueField serializer. Parameters dataclass A dataclass type to deserialize the embedded value to Returns A dataclass field descriptor. EmbeddedValueField Serializer field for decoding embeded resources of the form {\"value\": {...the thing we actually want }, \"links\": [...]} Wraps an inner serializer, extracts the value field from the returned data and returns that. Constructor : EmbeddedValueField(serializer, *args, **kwargs) Methods to_internal_value to_internal_value( self, data) Transform the incoming primitive data into a native value. to_representation to_representation( self, value) Transform the outgoing native value into primitive data.","title":"Groundwork.geo.territories.uk.internal.serializers"},{"location":"api/groundwork.geo.territories.uk.internal.serializers/#embedded_value","text":"embedded_value( dataclass: Type[Any]) \u2011> dataclasses.Field Convenience function for returning a dataclass field descriptor that informs DataclassSerializer that we wish to use the EmbeddedValueField serializer. Parameters dataclass A dataclass type to deserialize the embedded value to Returns A dataclass field descriptor.","title":"embedded_value"},{"location":"api/groundwork.geo.territories.uk.internal.serializers/#embeddedvaluefield","text":"Serializer field for decoding embeded resources of the form {\"value\": {...the thing we actually want }, \"links\": [...]} Wraps an inner serializer, extracts the value field from the returned data and returns that. Constructor : EmbeddedValueField(serializer, *args, **kwargs)","title":"EmbeddedValueField"},{"location":"api/groundwork.geo.territories.uk.internal.serializers/#methods","text":"","title":"Methods"},{"location":"api/groundwork.geo.territories.uk.internal.serializers/#to_internal_value","text":"to_internal_value( self, data) Transform the incoming primitive data into a native value.","title":"to_internal_value"},{"location":"api/groundwork.geo.territories.uk.internal.serializers/#to_representation","text":"to_representation( self, value) Transform the outgoing native value into primitive data.","title":"to_representation"},{"location":"api/groundwork.geo.territories.uk/","text":"import groundwork.geo.territories.uk groundwork.geo.territories.uk.internal groundwork.geo.territories.uk.ons groundwork.geo.territories.uk.parliament groundwork.geo.territories.uk.postcodes","title":"Groundwork.geo.territories.uk"},{"location":"api/groundwork.geo.territories.uk.ons/","text":"import groundwork.geo.territories.uk.ons OnsCode OnsCode(code: str, label: str) Properties All properties are valid as keyword-args to the constructor. They are required unless marked optional below. code str label str OnsCodeType Constructor : OnsCodeType() constituency_codes RestDatasource [ OnsCode ] Looks up ONS constituency resources mapping the official constituency name to its ONS code. This is primarily used internally to clean data returned by APIs that don't provide ONS codes.","title":"Groundwork.geo.territories.uk.ons"},{"location":"api/groundwork.geo.territories.uk.ons/#onscode","text":"OnsCode(code: str, label: str)","title":"OnsCode"},{"location":"api/groundwork.geo.territories.uk.ons/#properties","text":"All properties are valid as keyword-args to the constructor. They are required unless marked optional below.","title":"Properties"},{"location":"api/groundwork.geo.territories.uk.ons/#code","text":"str","title":"code"},{"location":"api/groundwork.geo.territories.uk.ons/#label","text":"str","title":"label"},{"location":"api/groundwork.geo.territories.uk.ons/#onscodetype","text":"Constructor : OnsCodeType()","title":"OnsCodeType"},{"location":"api/groundwork.geo.territories.uk.ons/#constituency_codes","text":"RestDatasource [ OnsCode ] Looks up ONS constituency resources mapping the official constituency name to its ONS code. This is primarily used internally to clean data returned by APIs that don't provide ONS codes.","title":"constituency_codes"},{"location":"api/groundwork.geo.territories.uk.parliament/","text":"import groundwork.geo.territories.uk.parliament Constituency Represent a Westminster constituency. Properties All properties are valid as keyword-args to the constructor. They are required unless marked optional below. current_representation Optional[ CurrentRepresentation ] end_date Optional[datetime.datetime] id int name str ons_code str start_date datetime.datetime CurrentRepresentation Represent a current MP. Properties All properties are valid as keyword-args to the constructor. They are required unless marked optional below. member Member representation Representation Member Represent an MP. Properties All properties are valid as keyword-args to the constructor. They are required unless marked optional below. gender str id int latest_house_membership Representation latest_party Optional[ Party ] name_address_as Optional[str] name_display_as str name_full_title str name_list_as str thumbnail_url str Party Represent a political party Properties All properties are valid as keyword-args to the constructor. They are required unless marked optional below. abbreviation Optional[str] background_colour Optional[str] foreground_colour Optional[str] government_type Optional[int] id int is_independent_party bool is_lords_main_party bool is_lords_spiritual_party bool name str Representation Represent an MP's period of representation in parliament. Properties All properties are valid as keyword-args to the constructor. They are required unless marked optional below. membership_from_id Optional[int] constituencies RestDatasource [ Constituency ] Resource returning all current UK constituencies, along with their current representation in parliament. members RestDatasource [ Member ] Resource returning all current UK MPs, along with their current representation in parliament. parties RestDatasource [ Party ] Resource returning all current UK political parties represented in Westminster","title":"Parliament API"},{"location":"api/groundwork.geo.territories.uk.parliament/#constituency","text":"Represent a Westminster constituency.","title":"Constituency"},{"location":"api/groundwork.geo.territories.uk.parliament/#properties","text":"All properties are valid as keyword-args to the constructor. They are required unless marked optional below.","title":"Properties"},{"location":"api/groundwork.geo.territories.uk.parliament/#current_representation","text":"Optional[ CurrentRepresentation ]","title":"current_representation"},{"location":"api/groundwork.geo.territories.uk.parliament/#end_date","text":"Optional[datetime.datetime]","title":"end_date"},{"location":"api/groundwork.geo.territories.uk.parliament/#id","text":"int","title":"id"},{"location":"api/groundwork.geo.territories.uk.parliament/#name","text":"str","title":"name"},{"location":"api/groundwork.geo.territories.uk.parliament/#ons_code","text":"str","title":"ons_code"},{"location":"api/groundwork.geo.territories.uk.parliament/#start_date","text":"datetime.datetime","title":"start_date"},{"location":"api/groundwork.geo.territories.uk.parliament/#currentrepresentation","text":"Represent a current MP.","title":"CurrentRepresentation"},{"location":"api/groundwork.geo.territories.uk.parliament/#properties_1","text":"All properties are valid as keyword-args to the constructor. They are required unless marked optional below.","title":"Properties"},{"location":"api/groundwork.geo.territories.uk.parliament/#member","text":"Member","title":"member"},{"location":"api/groundwork.geo.territories.uk.parliament/#representation","text":"Representation","title":"representation"},{"location":"api/groundwork.geo.territories.uk.parliament/#member_1","text":"Represent an MP.","title":"Member"},{"location":"api/groundwork.geo.territories.uk.parliament/#properties_2","text":"All properties are valid as keyword-args to the constructor. They are required unless marked optional below.","title":"Properties"},{"location":"api/groundwork.geo.territories.uk.parliament/#gender","text":"str","title":"gender"},{"location":"api/groundwork.geo.territories.uk.parliament/#id_1","text":"int","title":"id"},{"location":"api/groundwork.geo.territories.uk.parliament/#latest_house_membership","text":"Representation","title":"latest_house_membership"},{"location":"api/groundwork.geo.territories.uk.parliament/#latest_party","text":"Optional[ Party ]","title":"latest_party"},{"location":"api/groundwork.geo.territories.uk.parliament/#name_address_as","text":"Optional[str]","title":"name_address_as"},{"location":"api/groundwork.geo.territories.uk.parliament/#name_display_as","text":"str","title":"name_display_as"},{"location":"api/groundwork.geo.territories.uk.parliament/#name_full_title","text":"str","title":"name_full_title"},{"location":"api/groundwork.geo.territories.uk.parliament/#name_list_as","text":"str","title":"name_list_as"},{"location":"api/groundwork.geo.territories.uk.parliament/#thumbnail_url","text":"str","title":"thumbnail_url"},{"location":"api/groundwork.geo.territories.uk.parliament/#party","text":"Represent a political party","title":"Party"},{"location":"api/groundwork.geo.territories.uk.parliament/#properties_3","text":"All properties are valid as keyword-args to the constructor. They are required unless marked optional below.","title":"Properties"},{"location":"api/groundwork.geo.territories.uk.parliament/#abbreviation","text":"Optional[str]","title":"abbreviation"},{"location":"api/groundwork.geo.territories.uk.parliament/#background_colour","text":"Optional[str]","title":"background_colour"},{"location":"api/groundwork.geo.territories.uk.parliament/#foreground_colour","text":"Optional[str]","title":"foreground_colour"},{"location":"api/groundwork.geo.territories.uk.parliament/#government_type","text":"Optional[int]","title":"government_type"},{"location":"api/groundwork.geo.territories.uk.parliament/#id_2","text":"int","title":"id"},{"location":"api/groundwork.geo.territories.uk.parliament/#is_independent_party","text":"bool","title":"is_independent_party"},{"location":"api/groundwork.geo.territories.uk.parliament/#is_lords_main_party","text":"bool","title":"is_lords_main_party"},{"location":"api/groundwork.geo.territories.uk.parliament/#is_lords_spiritual_party","text":"bool","title":"is_lords_spiritual_party"},{"location":"api/groundwork.geo.territories.uk.parliament/#name_1","text":"str","title":"name"},{"location":"api/groundwork.geo.territories.uk.parliament/#representation_1","text":"Represent an MP's period of representation in parliament.","title":"Representation"},{"location":"api/groundwork.geo.territories.uk.parliament/#properties_4","text":"All properties are valid as keyword-args to the constructor. They are required unless marked optional below.","title":"Properties"},{"location":"api/groundwork.geo.territories.uk.parliament/#membership_from_id","text":"Optional[int]","title":"membership_from_id"},{"location":"api/groundwork.geo.territories.uk.parliament/#constituencies","text":"RestDatasource [ Constituency ] Resource returning all current UK constituencies, along with their current representation in parliament.","title":"constituencies"},{"location":"api/groundwork.geo.territories.uk.parliament/#members","text":"RestDatasource [ Member ] Resource returning all current UK MPs, along with their current representation in parliament.","title":"members"},{"location":"api/groundwork.geo.territories.uk.parliament/#parties","text":"RestDatasource [ Party ] Resource returning all current UK political parties represented in Westminster","title":"parties"},{"location":"api/groundwork.geo.territories.uk.postcodes/","text":"import groundwork.geo.territories.uk.postcodes GeolocatedPostcode Metadata about a geolocated postcode. Properties All properties are valid as keyword-args to the constructor. They are required unless marked optional below. admin_county Optional[str] admin_district str admin_ward str ccg str ced Optional[str] codes OnsCodes country str eastings int incode str latitude float longitude float lsoa str msoa str nhs_ha str northings int nuts str outcode str parish str parliamentary_constituency str postcode str primary_care_trust str quality int region str Methods to_point to_point( self) Representation of this postcode's geolocation as a Django GIS -compatible point. Returns A Django-GIS Point representing the postcode OnsCodes ONS Codes for UK governmental boundaries a postcode falls within. Properties All properties are valid as keyword-args to the constructor. They are required unless marked optional below. admin_county str admin_district str admin_ward str ccg str ccg_id str ced str lau2 str lsoa str msoa str nuts str parish str parliamentary_constituency str postcode RestDatasource [ GeolocatedPostcode ] Geolocated postcode API resource. Only GET requests are supported. get(postcode) : Geocodes `postcode` and returns a `GeolocatedPostcode` instance.","title":"Postcode Geolocation"},{"location":"api/groundwork.geo.territories.uk.postcodes/#geolocatedpostcode","text":"Metadata about a geolocated postcode.","title":"GeolocatedPostcode"},{"location":"api/groundwork.geo.territories.uk.postcodes/#properties","text":"All properties are valid as keyword-args to the constructor. They are required unless marked optional below.","title":"Properties"},{"location":"api/groundwork.geo.territories.uk.postcodes/#admin_county","text":"Optional[str]","title":"admin_county"},{"location":"api/groundwork.geo.territories.uk.postcodes/#admin_district","text":"str","title":"admin_district"},{"location":"api/groundwork.geo.territories.uk.postcodes/#admin_ward","text":"str","title":"admin_ward"},{"location":"api/groundwork.geo.territories.uk.postcodes/#ccg","text":"str","title":"ccg"},{"location":"api/groundwork.geo.territories.uk.postcodes/#ced","text":"Optional[str]","title":"ced"},{"location":"api/groundwork.geo.territories.uk.postcodes/#codes","text":"OnsCodes","title":"codes"},{"location":"api/groundwork.geo.territories.uk.postcodes/#country","text":"str","title":"country"},{"location":"api/groundwork.geo.territories.uk.postcodes/#eastings","text":"int","title":"eastings"},{"location":"api/groundwork.geo.territories.uk.postcodes/#incode","text":"str","title":"incode"},{"location":"api/groundwork.geo.territories.uk.postcodes/#latitude","text":"float","title":"latitude"},{"location":"api/groundwork.geo.territories.uk.postcodes/#longitude","text":"float","title":"longitude"},{"location":"api/groundwork.geo.territories.uk.postcodes/#lsoa","text":"str","title":"lsoa"},{"location":"api/groundwork.geo.territories.uk.postcodes/#msoa","text":"str","title":"msoa"},{"location":"api/groundwork.geo.territories.uk.postcodes/#nhs_ha","text":"str","title":"nhs_ha"},{"location":"api/groundwork.geo.territories.uk.postcodes/#northings","text":"int","title":"northings"},{"location":"api/groundwork.geo.territories.uk.postcodes/#nuts","text":"str","title":"nuts"},{"location":"api/groundwork.geo.territories.uk.postcodes/#outcode","text":"str","title":"outcode"},{"location":"api/groundwork.geo.territories.uk.postcodes/#parish","text":"str","title":"parish"},{"location":"api/groundwork.geo.territories.uk.postcodes/#parliamentary_constituency","text":"str","title":"parliamentary_constituency"},{"location":"api/groundwork.geo.territories.uk.postcodes/#postcode","text":"str","title":"postcode"},{"location":"api/groundwork.geo.territories.uk.postcodes/#primary_care_trust","text":"str","title":"primary_care_trust"},{"location":"api/groundwork.geo.territories.uk.postcodes/#quality","text":"int","title":"quality"},{"location":"api/groundwork.geo.territories.uk.postcodes/#region","text":"str","title":"region"},{"location":"api/groundwork.geo.territories.uk.postcodes/#methods","text":"","title":"Methods"},{"location":"api/groundwork.geo.territories.uk.postcodes/#to_point","text":"to_point( self) Representation of this postcode's geolocation as a Django GIS -compatible point. Returns A Django-GIS Point representing the postcode","title":"to_point"},{"location":"api/groundwork.geo.territories.uk.postcodes/#onscodes","text":"ONS Codes for UK governmental boundaries a postcode falls within.","title":"OnsCodes"},{"location":"api/groundwork.geo.territories.uk.postcodes/#properties_1","text":"All properties are valid as keyword-args to the constructor. They are required unless marked optional below.","title":"Properties"},{"location":"api/groundwork.geo.territories.uk.postcodes/#admin_county_1","text":"str","title":"admin_county"},{"location":"api/groundwork.geo.territories.uk.postcodes/#admin_district_1","text":"str","title":"admin_district"},{"location":"api/groundwork.geo.territories.uk.postcodes/#admin_ward_1","text":"str","title":"admin_ward"},{"location":"api/groundwork.geo.territories.uk.postcodes/#ccg_1","text":"str","title":"ccg"},{"location":"api/groundwork.geo.territories.uk.postcodes/#ccg_id","text":"str","title":"ccg_id"},{"location":"api/groundwork.geo.territories.uk.postcodes/#ced_1","text":"str","title":"ced"},{"location":"api/groundwork.geo.territories.uk.postcodes/#lau2","text":"str","title":"lau2"},{"location":"api/groundwork.geo.territories.uk.postcodes/#lsoa_1","text":"str","title":"lsoa"},{"location":"api/groundwork.geo.territories.uk.postcodes/#msoa_1","text":"str","title":"msoa"},{"location":"api/groundwork.geo.territories.uk.postcodes/#nuts_1","text":"str","title":"nuts"},{"location":"api/groundwork.geo.territories.uk.postcodes/#parish_1","text":"str","title":"parish"},{"location":"api/groundwork.geo.territories.uk.postcodes/#parliamentary_constituency_1","text":"str","title":"parliamentary_constituency"},{"location":"api/groundwork.geo.territories.uk.postcodes/#postcode_1","text":"RestDatasource [ GeolocatedPostcode ] Geolocated postcode API resource. Only GET requests are supported. get(postcode) : Geocodes `postcode` and returns a `GeolocatedPostcode` instance.","title":"postcode"},{"location":"components/map.components/","text":"Map Components Map Renders a Map onto the page. Django API Stimulus API {% load groundwork_geo %} {% map class = \"my-map-class\" center = \"[4.53,52.22]\" zoom = 9 %} <!-- Map config tags go here --> {% endmap %} Parameters element Optional. Return a cache key given the arguments to the function style Optional. Override the map style on a per-map basis. Defaults to the MAPBOX_DEFAULT_STYLE django config. api_key Optional. Override the map API key on a per-map basis. Defaults to the MAPBOX_PUBLIC_API_KEY django config. center Optional. Initial [lon,lat] location to center the map on. zoom Optional. Initial zoom value. Defaults to 2. Any additional arguments are passed to the map as attributes. < div class = \"my-map-class\" data-controller = \"map\" data-map-api-key-value = \"...\" data-map-api-center-value = \"[4.53,52.22]\" data-map-api-zoom-value = \"9\" > <!-- Map config tags go here --> < div data-map-target = \"canvas\" ></ div > </ div > Values api-key A valid mapbox public API key center JSON array representing a [lon,lat] pair to initially center the map on. zoom Initial map zoom value. Defaults to 2. style Style for the map. Defaults to mapbox/streets-v11 . Targets canvas Required. An element to render the map into. config One or more map config elements. These should have a controller that subclasses MapConfigController Map source Adds a datasource to a map. Django API Stimulus API {% load groundwork_geo %} {% map %} {% map_source id = \"my_datasource_id\" data = my_datasource %} {% endmap %} Parameters id ID for the datasource made available to layers data JSON object conforming to the Mapbox source specification < div data-controller = \"map\" data-map-api-key-value = \"...\" > < div data-controller = \"map-source\" data-map-target = \"config\" data-map-source-id-value = \"my_datasource_id\" data-map-source-data-value = '{\"type\": \"geojson\", \"url\": \"mapbox://mapbox.mapbox-terrain-v2\"}' > </ div > < div data-map-target = \"canvas\" ></ div > </ div > Parameters id ID for the datasource made available to layers data JSON object conforming to the Mapbox source specification Map layer Adds a layer to a map. Django API Stimulus API {% load groundwork_geo %} {% map %} {% map_layer layer = my_layer %} {% endmap %} Parameters layer JSON object conforming to the Mapbox layer specification < div data-controller = \"map\" data-map-api-key-value = \"xxx\" > < div data-controller = \"map-layer\" data-map-target = \"config\" data-map-layer-layer-value = '{\"id\": \"terrain-data\", \"type\": \"line\", \"source\": \"mapbox-terrain\", ...}' > </ div > < div data-map-target = \"canvas\" ></ div > </ div > Parameters layer JSON object conforming to the Mapbox layer specification","title":"Map Components"},{"location":"components/map.components/#map-components","text":"","title":"Map Components"},{"location":"components/map.components/#map","text":"Renders a Map onto the page. Django API Stimulus API {% load groundwork_geo %} {% map class = \"my-map-class\" center = \"[4.53,52.22]\" zoom = 9 %} <!-- Map config tags go here --> {% endmap %} Parameters element Optional. Return a cache key given the arguments to the function style Optional. Override the map style on a per-map basis. Defaults to the MAPBOX_DEFAULT_STYLE django config. api_key Optional. Override the map API key on a per-map basis. Defaults to the MAPBOX_PUBLIC_API_KEY django config. center Optional. Initial [lon,lat] location to center the map on. zoom Optional. Initial zoom value. Defaults to 2. Any additional arguments are passed to the map as attributes. < div class = \"my-map-class\" data-controller = \"map\" data-map-api-key-value = \"...\" data-map-api-center-value = \"[4.53,52.22]\" data-map-api-zoom-value = \"9\" > <!-- Map config tags go here --> < div data-map-target = \"canvas\" ></ div > </ div > Values api-key A valid mapbox public API key center JSON array representing a [lon,lat] pair to initially center the map on. zoom Initial map zoom value. Defaults to 2. style Style for the map. Defaults to mapbox/streets-v11 . Targets canvas Required. An element to render the map into. config One or more map config elements. These should have a controller that subclasses MapConfigController","title":"Map"},{"location":"components/map.components/#map-source","text":"Adds a datasource to a map. Django API Stimulus API {% load groundwork_geo %} {% map %} {% map_source id = \"my_datasource_id\" data = my_datasource %} {% endmap %} Parameters id ID for the datasource made available to layers data JSON object conforming to the Mapbox source specification < div data-controller = \"map\" data-map-api-key-value = \"...\" > < div data-controller = \"map-source\" data-map-target = \"config\" data-map-source-id-value = \"my_datasource_id\" data-map-source-data-value = '{\"type\": \"geojson\", \"url\": \"mapbox://mapbox.mapbox-terrain-v2\"}' > </ div > < div data-map-target = \"canvas\" ></ div > </ div > Parameters id ID for the datasource made available to layers data JSON object conforming to the Mapbox source specification","title":"Map source"},{"location":"components/map.components/#map-layer","text":"Adds a layer to a map. Django API Stimulus API {% load groundwork_geo %} {% map %} {% map_layer layer = my_layer %} {% endmap %} Parameters layer JSON object conforming to the Mapbox layer specification < div data-controller = \"map\" data-map-api-key-value = \"xxx\" > < div data-controller = \"map-layer\" data-map-target = \"config\" data-map-layer-layer-value = '{\"id\": \"terrain-data\", \"type\": \"line\", \"source\": \"mapbox-terrain\", ...}' > </ div > < div data-map-target = \"canvas\" ></ div > </ div > Parameters layer JSON object conforming to the Mapbox layer specification","title":"Map layer"},{"location":"guides/data-pipeline/","text":"Django ships out of the box with an excellent ORM for modeling data created and managed by our application. This is useful for several reasons, but mainly: Consistent conventions mean less surprises about how different things work. The standardised model/queryset format allows the framework to support generic views, forms and other components. Unfortunately, they don't help so much with external data - either public data that we want to be informed of changes to or data managed by external services. This gets particuarly tricky when we want to augment the remote data with our own data or there are API limits that require us to store the data locally and keep it up to date. We often end up writing lots of bug-prone glue code to manage this. Groundwork helps here by introducing a lightweight abstraction called a Datasource . It might be helpful to think of these as similar to Django' models and querysets, but for external APIs. In the examples that follow, we use a very common use-case for building out applications that help people organise. There is a campaign that needs to carve up people by the UK parliamentary constitutency they are in and add other information the campaign is concerned about that relate to it. The amount of people who support an action. The number of letter sent in this constituency to lobby an MP. There might be a model to represent this letter, for example. So we need to represent the constituencies and information about them against a source of truth, but augment this with things that we want to know about. But loading in all constituencies, or looking up this data on the fly, is slow or error prone. The data around constituencies also changes very infrequently. Datasources tries to solve for this situation which we have observed a fair amount in our own work and provide a lightweight API for doing so. About datasources A datasource is a simple interface that defines: A method to get objects by ID. A method to list (and optionally sort or filter) objects. A type that returned objects should be assumed to be instances of. A field on that type that provides the object's ID. You can check out the documentation for the Datasource class for more detail on this. For now, we'll look at one thing we can do with them \u2013 regularly synchronising data from a remote service. Synchronising data from a remote service For this example, we'll pull in a list of all the constituencies in the UK using Groundwork's built-in UK parliamentary datasource. It's not the most interesting example, but works for explaining things. We'll configure it to update periodically so that changes to UK constituencies are reflected in our local models. Warning Just because you can pull in lots of data in from other systems doesn't mean you should . Be mindful about any personal data that you're pulling in from CRMs, etc. Don't store more than you need, anonymise as necessary and ensure that your environment is secure relative to the sensitivity of the data you are storing and your threat model. Create your model First, we'll create our model. To make this easier, we'll make the field names in our model match the field names in the datasource. The datasources provided with Groundwork are all documented and have type hints on the objects they return. The UK Parliament datasource is documented here . Some things to note: We're subclassing SyncedModel . This is needed to register the model with the sync manager. We configure where to fetch the data from, how often, and how to map it onto our local model using SyncConfig . We need to store the id used by the remote data source. By default, this is called external_id , but you can customize this. We need to add the fields we want to save data from in our model. It's absolutely fine to leave out fields that you don't want to save. app/models.py from django.db import models from groundwork.core.datasources import SyncedModel , SyncConfig from groundwork.geo.territories.uk import parliament class Constituency ( SyncedModel ): # This is where we specify the datasource, along with other options # for customizing how synchronization happens. sync_config = SyncConfig ( datasource = parliament . constituencies , ) # This is used to join data returned from the remote API against # our local data. external_id = models . IntegerField () # This will be populated from the remote data. name = models . CharField ( max_length = 256 ) Configure a cron process Groundwork comes with a management command for running background cron processes. Where you run it will depend on your server setup, but you can launch it by running: python manage.py run_cron_tasks This will start a clock process which periodically checks for any pending cron tasks and runs them. It runs until you close it. For relatively small projects running on a single instance, you might find it convenient to have a launch script that runs the cron process in the background: run.sh python manage.py run_cron_tasks & gunicorn app.wsgi Or on larger installations using an IAAS platform like Heroku, you might want to configure a dedicated box to run the cron tasks: Procfile web : gunicorn app.wsgi clock : python manage.py run_cron_tasks In development, you might want to just run all registered cron tasks then exit. You can do this with the --once flag. We'll do that now: python manage.py run_cron_tasks --once That's it! You now have a list of UK constituencies saved to your database. On its own, this isn't very interesting. To make this more useful, the next tutorial will look at relationships. Handling relationships Often, we find ourselves wanting to preserve relationships between resources we're pulling in from remote APIs. Groundwork's SyncedModel supports following relationships on remote resources and recreating them locally. It will do this when your model definition has any of: A foreign key to another SyncedModel A many-many relationship to another SyncedModel An inverse relationship to another synced model And the resource returned by the datasource has a field mapped to the model field where: A str , int or uuuid value that can be passed to the datasource's get method. An embedded instance of the related model's resource type. In the case of to-many relationship, a list of either of these. Let's expand our example to include data about the current MP for the constituencies we just pulled in. app/models.py from django.db import models from groundwork.core.datasources import SyncedModel , SyncConfig from groundwork.geo.territories.uk import parliament class Constituency ( SyncedModel ): # This is where we specify the datasource, along with other options # for customizing how synchronization happens. sync_config = SyncConfig ( datasource = parliament . constituencies , ) # This is used to join data returned from the remote API against # our local data. external_id = models . IntegerField () # This will be populated from the remote data. name = models . CharField ( max_length = 256 ) # This will be populated from the remote data. current_mp = models . ForeignKey ( 'MP' , null = True , on_delete = models . SET_NULL ) class MP ( SyncedModel ): # This is where we specify the datasource, along with other options # for customizing how synchronization happens. sync_config = SyncConfig ( datasource = parliament . members , ) # This is used to join data returned from the remote API against # our local data. external_id = models . IntegerField () # This will be populated from the remote data. name = models . CharField ( max_length = 256 ) # This will be populated from the remote data. thumbnail_url = models . URLField ( null = True ) # This will be populated from the remote data. latest_party = models . ForeignKey ( 'Party' , null = True , on_delete = models . SET_NULL ) class Party ( SyncedModel ): # This is where we specify the datasource, along with other options # for customizing how synchronization happens. sync_config = SyncConfig ( datasource = parliament . parties , ) # This is used to join data returned from the remote API against # our local data. external_id = models . IntegerField () # This will be populated from the remote data. name = models . CharField ( max_length = 256 ) # This will be populated from the remote data. background_colour = models . CharField ( max_length = 256 ) That's it! Generate and run migrations for the new models, run python manage.py run_cron_tasks --once again and you now have the UK's westminster representitives (and their thumbnails) stored in your database. We used this example not because it's especially interesting politically, but because it uses an open API that doesn't require configuration. However, the same principles here apply to anything \u2013 membership databases, event listings, or other services specific to your organisation. Provided datasources UK Parliament Members & Constituencies UK Postcode Geocoding Forthcoming: Action Network Airtable Google Sheets Nationbuilder Stripe Writing your own datasource Adapting an existing client library Many services provide their own Python client library. If the one you're building a datasource for does, it's better to simply adapt it in the Datasource interface than reinvent the wheel. To do this, extend Datasource . You need to implement get() which should get a resource by id and list() , which should list resources, optionally filtering them. Let's do that for a client library for an imaginary service classed ZapMessage . Here we're assuming that its client library has a class for each resource type and that these all have a get() and filter() class method to fetch from the API: app/datasources/zapmessage.py from typing import TypeVar , Iterable , Any import zapmessage from django.conf import settings from groundwork.core.datasources import Datasource # We're using type hints in this example, but feel free to ignore them if # they're unfamiliar. ResourceT = typing . TypeVar ( 'ResourceT' ) class ZapMessageResource ( Datasource [ ResourceT ]): class NotFoundError ( Exception ): pass # The Datasource class will set any keyword-args provided to the # constructor as instance variables. We add this type hint to document # that this is expected. resource_type : zapmessage . Resource def get ( self , id : str ) -> ResourceT : response = self . resource_type . get ( id , api_key = self . api_key ) if response is None : raise ZapMessageResource . NotFoundError ( f 'not found: { id } ' ) return response def list ( self , ** filter : Any ) -> Iterable [ ResourceT ]: return self . resource_type . filter ( api_key = self . api_key , ** filter ) @property def api_key ( self ): return setting . ZAPMESSAGE_API_KEY messages : Datasource [ zapmessage . Message ] = ZapMessageResource ( resource_type = zapmessage . Message ) senders : Datasource [ zapmessage . MessageSender ] = ZapMessageResource ( resource_type = zapmessage . MessageSender ) categories : Datasource [ zapmessage . MessageCategory ] = ZapMessageResource ( resource_type = zapmessage . MessageCategory ) Now we can pass any of these resource endpoints to any API accepting a Datasource. If the client library is designed well (as this one is), it will probably have consistent conventions for how its different resources work. If so, you can probably just define one class adopting the API's overall conventions and customize those using parameters to instances for individual resources. A real-world example will obviously differ, and may introduce a few inconsistencies that you need to work around but hopefully this gives you a good starting point! Calling a REST API Let's imagine that ZapMessage didn't provide a Python library and we needed to use its REST API instead. To do this, we'll need to: Define data classes for each resource. If we need specify headers or otherwise customize how API calls are made, subclass RestDatasource with our customizations. app/datasources/zapmessage.py from dataclasses import dataclass from datetime import datetime from typing import TypeVar , Iterable , Any , Dict from django.conf import settings from groundwork.core.datasources import RestDatasource @dataclass class Message : id : str sender_id : str category_id : str timestamp : datetime content : str @dataclass class MessageSender : id : str name : str @dataclass class MessageSender : id : str name : str # We're using type hints in this example, but feel free to ignore them if # they're unfamiliar. ResourceT = typing . TypeVar ( 'ResourceT' ) class ZapMessageResource ( RestDatasource [ ResourceT ]): base_url = 'https://api.zapmessage.io' def get_headers ( self ) -> Dict [ str , str ]: return { 'Authorization' : f 'Bearer { settings . ZAPMESSAGE_API_KEY } ' } messages : RestDatasource [ Message ] = ZapMessageResource ( path = '/messages' , resource_type = Message ) senders : RestDatasource [ MessageSender ] = ZapMessageResource ( path = '/senders' , resource_type = MessageSender ) categories : RestDatasource [ MessageCategory ] = ZapMessageResource ( path = '/categories' , resource_type = MessageCategory ) So far, so good! One additional customization we will often make is to define how list responses are handled. By default, RestClient's list() call will expect to be returned a list of resources with no pagination. Here's how we might do that: class ZapMessageResource ( RestDatasource [ ResourceT ]): base_url = 'https://api.zapmessage.io' def get_headers ( self ) -> Dict [ str , str ]: return { 'Authorization' : f 'Bearer { settings . ZAPMESSAGE_API_KEY } ' } def paginate ( self , ** query : Any ) -> Iterable [ Any ]: page = 1 total_pages = None while total_pages is None or page <= total_pages > : response = self . fetch_url ( self . url , query , page = page ) total_pages = response [ 'total_pages' ] for item in response [ 'items' ]: yield item You can see the full set of options and override points in RestClient 's API documentation.","title":"Data Pipeline"},{"location":"guides/data-pipeline/#about-datasources","text":"A datasource is a simple interface that defines: A method to get objects by ID. A method to list (and optionally sort or filter) objects. A type that returned objects should be assumed to be instances of. A field on that type that provides the object's ID. You can check out the documentation for the Datasource class for more detail on this. For now, we'll look at one thing we can do with them \u2013 regularly synchronising data from a remote service.","title":"About datasources"},{"location":"guides/data-pipeline/#synchronising-data-from-a-remote-service","text":"For this example, we'll pull in a list of all the constituencies in the UK using Groundwork's built-in UK parliamentary datasource. It's not the most interesting example, but works for explaining things. We'll configure it to update periodically so that changes to UK constituencies are reflected in our local models. Warning Just because you can pull in lots of data in from other systems doesn't mean you should . Be mindful about any personal data that you're pulling in from CRMs, etc. Don't store more than you need, anonymise as necessary and ensure that your environment is secure relative to the sensitivity of the data you are storing and your threat model.","title":"Synchronising data from a remote service"},{"location":"guides/data-pipeline/#create-your-model","text":"First, we'll create our model. To make this easier, we'll make the field names in our model match the field names in the datasource. The datasources provided with Groundwork are all documented and have type hints on the objects they return. The UK Parliament datasource is documented here . Some things to note: We're subclassing SyncedModel . This is needed to register the model with the sync manager. We configure where to fetch the data from, how often, and how to map it onto our local model using SyncConfig . We need to store the id used by the remote data source. By default, this is called external_id , but you can customize this. We need to add the fields we want to save data from in our model. It's absolutely fine to leave out fields that you don't want to save. app/models.py from django.db import models from groundwork.core.datasources import SyncedModel , SyncConfig from groundwork.geo.territories.uk import parliament class Constituency ( SyncedModel ): # This is where we specify the datasource, along with other options # for customizing how synchronization happens. sync_config = SyncConfig ( datasource = parliament . constituencies , ) # This is used to join data returned from the remote API against # our local data. external_id = models . IntegerField () # This will be populated from the remote data. name = models . CharField ( max_length = 256 )","title":"Create your model"},{"location":"guides/data-pipeline/#configure-a-cron-process","text":"Groundwork comes with a management command for running background cron processes. Where you run it will depend on your server setup, but you can launch it by running: python manage.py run_cron_tasks This will start a clock process which periodically checks for any pending cron tasks and runs them. It runs until you close it. For relatively small projects running on a single instance, you might find it convenient to have a launch script that runs the cron process in the background: run.sh python manage.py run_cron_tasks & gunicorn app.wsgi Or on larger installations using an IAAS platform like Heroku, you might want to configure a dedicated box to run the cron tasks: Procfile web : gunicorn app.wsgi clock : python manage.py run_cron_tasks In development, you might want to just run all registered cron tasks then exit. You can do this with the --once flag. We'll do that now: python manage.py run_cron_tasks --once That's it! You now have a list of UK constituencies saved to your database. On its own, this isn't very interesting. To make this more useful, the next tutorial will look at relationships.","title":"Configure a cron process"},{"location":"guides/data-pipeline/#handling-relationships","text":"Often, we find ourselves wanting to preserve relationships between resources we're pulling in from remote APIs. Groundwork's SyncedModel supports following relationships on remote resources and recreating them locally. It will do this when your model definition has any of: A foreign key to another SyncedModel A many-many relationship to another SyncedModel An inverse relationship to another synced model And the resource returned by the datasource has a field mapped to the model field where: A str , int or uuuid value that can be passed to the datasource's get method. An embedded instance of the related model's resource type. In the case of to-many relationship, a list of either of these. Let's expand our example to include data about the current MP for the constituencies we just pulled in. app/models.py from django.db import models from groundwork.core.datasources import SyncedModel , SyncConfig from groundwork.geo.territories.uk import parliament class Constituency ( SyncedModel ): # This is where we specify the datasource, along with other options # for customizing how synchronization happens. sync_config = SyncConfig ( datasource = parliament . constituencies , ) # This is used to join data returned from the remote API against # our local data. external_id = models . IntegerField () # This will be populated from the remote data. name = models . CharField ( max_length = 256 ) # This will be populated from the remote data. current_mp = models . ForeignKey ( 'MP' , null = True , on_delete = models . SET_NULL ) class MP ( SyncedModel ): # This is where we specify the datasource, along with other options # for customizing how synchronization happens. sync_config = SyncConfig ( datasource = parliament . members , ) # This is used to join data returned from the remote API against # our local data. external_id = models . IntegerField () # This will be populated from the remote data. name = models . CharField ( max_length = 256 ) # This will be populated from the remote data. thumbnail_url = models . URLField ( null = True ) # This will be populated from the remote data. latest_party = models . ForeignKey ( 'Party' , null = True , on_delete = models . SET_NULL ) class Party ( SyncedModel ): # This is where we specify the datasource, along with other options # for customizing how synchronization happens. sync_config = SyncConfig ( datasource = parliament . parties , ) # This is used to join data returned from the remote API against # our local data. external_id = models . IntegerField () # This will be populated from the remote data. name = models . CharField ( max_length = 256 ) # This will be populated from the remote data. background_colour = models . CharField ( max_length = 256 ) That's it! Generate and run migrations for the new models, run python manage.py run_cron_tasks --once again and you now have the UK's westminster representitives (and their thumbnails) stored in your database. We used this example not because it's especially interesting politically, but because it uses an open API that doesn't require configuration. However, the same principles here apply to anything \u2013 membership databases, event listings, or other services specific to your organisation.","title":"Handling relationships"},{"location":"guides/data-pipeline/#provided-datasources","text":"UK Parliament Members & Constituencies UK Postcode Geocoding Forthcoming: Action Network Airtable Google Sheets Nationbuilder Stripe","title":"Provided datasources"},{"location":"guides/data-pipeline/#writing-your-own-datasource","text":"","title":"Writing your own datasource"},{"location":"guides/data-pipeline/#adapting-an-existing-client-library","text":"Many services provide their own Python client library. If the one you're building a datasource for does, it's better to simply adapt it in the Datasource interface than reinvent the wheel. To do this, extend Datasource . You need to implement get() which should get a resource by id and list() , which should list resources, optionally filtering them. Let's do that for a client library for an imaginary service classed ZapMessage . Here we're assuming that its client library has a class for each resource type and that these all have a get() and filter() class method to fetch from the API: app/datasources/zapmessage.py from typing import TypeVar , Iterable , Any import zapmessage from django.conf import settings from groundwork.core.datasources import Datasource # We're using type hints in this example, but feel free to ignore them if # they're unfamiliar. ResourceT = typing . TypeVar ( 'ResourceT' ) class ZapMessageResource ( Datasource [ ResourceT ]): class NotFoundError ( Exception ): pass # The Datasource class will set any keyword-args provided to the # constructor as instance variables. We add this type hint to document # that this is expected. resource_type : zapmessage . Resource def get ( self , id : str ) -> ResourceT : response = self . resource_type . get ( id , api_key = self . api_key ) if response is None : raise ZapMessageResource . NotFoundError ( f 'not found: { id } ' ) return response def list ( self , ** filter : Any ) -> Iterable [ ResourceT ]: return self . resource_type . filter ( api_key = self . api_key , ** filter ) @property def api_key ( self ): return setting . ZAPMESSAGE_API_KEY messages : Datasource [ zapmessage . Message ] = ZapMessageResource ( resource_type = zapmessage . Message ) senders : Datasource [ zapmessage . MessageSender ] = ZapMessageResource ( resource_type = zapmessage . MessageSender ) categories : Datasource [ zapmessage . MessageCategory ] = ZapMessageResource ( resource_type = zapmessage . MessageCategory ) Now we can pass any of these resource endpoints to any API accepting a Datasource. If the client library is designed well (as this one is), it will probably have consistent conventions for how its different resources work. If so, you can probably just define one class adopting the API's overall conventions and customize those using parameters to instances for individual resources. A real-world example will obviously differ, and may introduce a few inconsistencies that you need to work around but hopefully this gives you a good starting point!","title":"Adapting an existing client library"},{"location":"guides/data-pipeline/#calling-a-rest-api","text":"Let's imagine that ZapMessage didn't provide a Python library and we needed to use its REST API instead. To do this, we'll need to: Define data classes for each resource. If we need specify headers or otherwise customize how API calls are made, subclass RestDatasource with our customizations. app/datasources/zapmessage.py from dataclasses import dataclass from datetime import datetime from typing import TypeVar , Iterable , Any , Dict from django.conf import settings from groundwork.core.datasources import RestDatasource @dataclass class Message : id : str sender_id : str category_id : str timestamp : datetime content : str @dataclass class MessageSender : id : str name : str @dataclass class MessageSender : id : str name : str # We're using type hints in this example, but feel free to ignore them if # they're unfamiliar. ResourceT = typing . TypeVar ( 'ResourceT' ) class ZapMessageResource ( RestDatasource [ ResourceT ]): base_url = 'https://api.zapmessage.io' def get_headers ( self ) -> Dict [ str , str ]: return { 'Authorization' : f 'Bearer { settings . ZAPMESSAGE_API_KEY } ' } messages : RestDatasource [ Message ] = ZapMessageResource ( path = '/messages' , resource_type = Message ) senders : RestDatasource [ MessageSender ] = ZapMessageResource ( path = '/senders' , resource_type = MessageSender ) categories : RestDatasource [ MessageCategory ] = ZapMessageResource ( path = '/categories' , resource_type = MessageCategory ) So far, so good! One additional customization we will often make is to define how list responses are handled. By default, RestClient's list() call will expect to be returned a list of resources with no pagination. Here's how we might do that: class ZapMessageResource ( RestDatasource [ ResourceT ]): base_url = 'https://api.zapmessage.io' def get_headers ( self ) -> Dict [ str , str ]: return { 'Authorization' : f 'Bearer { settings . ZAPMESSAGE_API_KEY } ' } def paginate ( self , ** query : Any ) -> Iterable [ Any ]: page = 1 total_pages = None while total_pages is None or page <= total_pages > : response = self . fetch_url ( self . url , query , page = page ) total_pages = response [ 'total_pages' ] for item in response [ 'items' ]: yield item You can see the full set of options and override points in RestClient 's API documentation.","title":"Calling a REST API"},{"location":"guides/getting-started/","text":"Groundwork is distributed as a Python library via PyPI . Frontend components are distibuted via NPM . Using a starter kit The simplest way to get started using Groundwork is to clone our starter repository . To do this: Create a new repository from our template Follow the setup instructions in the new repository's readme.","title":"Getting Started"},{"location":"guides/getting-started/#using-a-starter-kit","text":"The simplest way to get started using Groundwork is to clone our starter repository . To do this: Create a new repository from our template Follow the setup instructions in the new repository's readme.","title":"Using a starter kit"}]}